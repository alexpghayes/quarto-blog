---
title: "multilaterion"
subtitle: |
  todo
date: "2024-11-01"
draft: true
---

```{r}
library(tidyverse)

# pulled from https://www.city-data.com/towers/cell-Madison-Wisconsin.html
cell_towers <- tribble(
  ~address,                ~latitude,   ~longitude,
  "149 Wabesa Street",     43.097222,  -89.342306,
  "1844 Fordem Avenue",    43.096389,  -89.363333,
  "122 W. Main Street",    43.072722,  -89.385194,
  "600 Highland Ave",      43.075556,  -89.431944,
  "1410 Regent Street",    43.068056,  -89.409444
)
```


```{r}
library(tidygeocoder)

breese_stevens_address <- "917 E Mifflin St, Madison, WI 53703"
crash <- tibble(address = breese_stevens_address) |> 
  geocode(address, method = "osm")
crash
```
```{r}
library(geodist)

distances <- cell_towers |>
  mutate(
    dist_meters = drop(
      geodist(
        cell_towers,
        crash,
        measure = "geodesic"
      )
    ),
    dist_meters_rounded = signif(dist_meters, digits = 2)
  )

distances
```

## A cool `nls()` tricky (not my own)

why this is cool, don't need to know anything about internals of geodist, it's a highly performant C++ nonlinearity

flip side of this trick: failure with fewer data points although it should be fine

another approach here: code up a loss function in jax, gradient descend since things should be convex. infrastructure not quite as desired though, super convenient when exploring to not need to write up. would be nice if nls() were a little more transparent in its errors and more stable though.

```{r}
# key to subset to only data needed for distance computations for some reason
nls_data <- distances |> 
  select(latitude, longitude, dist_meters_rounded) |> 
  head(4)

# https://www.appelsiini.net/2017/trilateration-with-n-points/
nls_fit <- nls(
  dist_meters_rounded ~ geodist(
    nls_data,
    c(
      longitude = longitude,
      latitude = latitude
    ),
    measure = "geodesic"
  ),
  data = nls_data,
  start = c(
    longitude = mean(nls_data$longitude),
    latitude = mean(nls_data$latitude)
  ),
  control = list(
    maxiter = 1000,
    tol = 0.00001,
    # help avoid convergence testing failure under perfect prediction
    scaleOffset = 1
  )
)
```

```{r}
library(ellipse)
library(sf)
library(glue)

# https://stackoverflow.com/questions/48383990/convert-sequence-of-longitude-and-latitude-to-polygon-via-sf-in-r
# https://r-charts.com/spatial/interactive-maps-leaflet/#polygons

uncertainty_ellipse <- ellipse(nls_fit) |>
  as.data.frame() |>

  # turn uncertainty ellipse into sf object
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) |>
  summarize(geometry = st_combine(geometry)) |>
  st_cast("POLYGON") |>

  # convert to leaflet project
  st_transform(crs = '+proj=longlat +datum=WGS84')


leaflet_data <- distances |>
  # add_row(
  #   address = "crash",
  #   latitude = coef(nls_fit)["latitude"],
  #   longitude = coef(nls_fit)["longitude"],
  # ) |>
  mutate(
    color = "blue",
    label_chr = glue(
      "<p>{address}</p>
       <p>{round(dist_meters)} meters from crash</p>"
    ),
    label_html = map(label_chr, htmltools::HTML)
  )

library(leaflet)

annotated_map <- leaflet() |>
  addTiles() |>
  setView(
    lng = mean(leaflet_data$longitude),
    lat = mean(leaflet_data$latitude),
    zoom = 13
  ) |>
  addCircleMarkers(
    data = leaflet_data,
    color = leaflet_data$color,
    label = leaflet_data$label_html
  ) |>
  addPolygons(
    data = uncertainty_ellipse,
    color = "red",
    stroke = 1
  )

annotated_map
```

## bringing even more infrastructure to the problem

suppose we want to build out more of a model for this thing. might have measurement error or outcome censoring, etc, etc

my go-to move would be to use brms() to think as little about this problem as possible (i do not want to write out a censored likelihood for this problem, or even commit to a particular distributional family just yet)

and we can do that, but we do need to implement the non-linearity in terms of things that brms can understand. this is a useful trick

BRMS implementation goes here

- try to fit with informative prior
- try to fit with uninformative prior

presumably both don't work

## is it possible for bayesians to do multilaterion?

cite the false confidence theorem paper multilaterion in the satelite context, this is just  a simpler and easier to visualize version of the same phenomenon

aside about representations of a priori uncertainty

bayesian multilateration paper with very silly prior


conclusions:

- nls is cool
- a lot of trick can be ported to brms (non-linearity in either R or stan C++)
- not sure if there's a nice way to do this estimation as a bayesian, would love to hear if there is

