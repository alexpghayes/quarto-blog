{
  "hash": "049c25b9b4fafb6e15f551dfd864cecf",
  "result": {
    "markdown": "---\ntitle: \"to transform or not to transform\"\nsubtitle: |\n  a likelihood ratio test to check if transforming your data leads to better model fit\ndate: \"2020-03-22\"\nbibliography: to-transform-or-not-to-transform.bib\nexecute:\n  echo: true\n  message: false\n  warning: false\ncategories: [math stat, methods, notes to self]\n---\n\nYou may have heard that it is impossible to compare models when the outcome has been transformed in one model but not the other. This is not the case. Models fit to transformed data implicitly model the original data as well as the transformed data, and it is relatively straightforward to calculate the corresponding likelihoods. In this post, I'll show you how to calculate these induced likelihoods. This will allow you to compare models fit to transformed data  with models fit to the original, untransformed data.\n\n## Setting\n\nLet's assume have some continuous data $x_1, ..., x_n$ that is independent and identically distributed. We transform this data via a nice, one-to-one function $g : \\mathbb{R} \\to \\mathbb{R}$ that sends $x \\mapsto g(x)$ to create a new data set $y_1, ..., y_n$, such that $y_i = g(x_i)$. We fit a model $\\mathcal M_x$ on the original data $x_1, ..., x_n$ and a model $\\mathcal M_y$ on the transformed data $y_1, ..., y_n$. Call the density of $\\mathcal M_x$ and $\\mathcal M_y$ respectively $f_x$ and $f_y$.\n\nSince $\\mathcal M_x$ and $\\mathcal M_y$ have been fit on different datasets, standard tools to compare $\\mathcal M_x$ and $\\mathcal M_y$ aren't immediately applicable, and we have to use some tricks to compare them. Note that [the internet][so-aic] (and literature, for example @burnham_model_2002 p. 81-82) is littered with people saying that you can't compare $\\mathcal M_x$ and $\\mathcal M_y$, and the few references (for example @akaike_likelihood_1978) that do discuss [how to compare models][cv-faq] with transformed responses are [light on details][mesquite].\n\n[so-aic]: https://stats.stackexchange.com/questions/61332/comparing-aic-of-a-model-and-its-log-transformed-version\n\n[mesquite]: https://avehtari.github.io/ROS-Examples/Mesquite/mesquite.html\n\n[cv-faq]: https://avehtari.github.io/modelselection/CV-FAQ.html\n\n## That density transformation stuff that everyone is always forgetting\n\nThe key observation is that putting a model on the $y_i$ is equivalent to putting a model on the $x_i$ since $g$ is a one-to-one mapping and $y_i = g(x_i)$. In particular, $\\mathcal M_y$ has a density in terms of $x$, in addition to have a density in terms of $y$. Let's call this density $f_{x'}$. \n\nAt this point, we have to remember how transformations affect densities, which I always have to look up because I forget (@casella_statistical_2002 section 4.6 is one reference). In particular, for an individual $y_i$, we have \n\n\\begin{align}\n  f_y(y_i) = f_{x'}(g^{-1} (y_i)) \\cdot \\left \\vert \\frac{\\partial g^{-1}}{\\partial y} (y_i) \\right \\vert,\n\\end{align}\n\nwhere the second term comes the Jacobian correction when doing a transformation of variables during integration. Working with individual individual data points is acceptable because we assume that the data points are indepedent and $y_i$ is only a function of $x_i$. Anyway, we leverage the transformed density to compute the log-likelihood of the $y_i$ under $\\mathcal M_y$ and find\n\n\\begin{align}\n  \\log \\mathcal L(y_1, ..., y_n | \\mathcal M_{y})\n  &= \\sum_{i=1}^n \\log f_y(y_i) \\\\\n  &= \\sum_{i=1}^n \\log f_{x'}(g^{-1} (y_i)) + \\log \\left \\vert \\frac{\\partial g^{-1}}{\\partial y} (y_i) \\right \\vert \\\\\n  &= \\sum_{i=1}^n \\log f_{x'}(x_i) + \\log \\left \\vert \\frac{\\partial g^{-1}}{\\partial y} (y_i) \\right \\vert.\n\\end{align}\n\nThis is promising, because the $\\sum_{i=1}^n \\log f_{x'}(x_i)$ term is the induced log-likelihood of $\\mathcal M_y$ on the original data $x_i$, which is exactly what we want. Rearranging, we find\n\n\\begin{align}\n  \\log \\mathcal L(x_1, ..., x_n | \\mathcal M_y) \n  &= \\sum_{i=1}^n \\log f_{x'}(x_i) \\\\\n  &= \\log \\mathcal L(y_1, ..., y_n | \\mathcal M_y) - \\sum_{i=1}^n \\log \\left \\vert \\frac{\\partial g^{-1}}{\\partial y} (y_i) \\right \\vert.\n\\end{align}\n\nSo we can use a standard log-likelihood calculation for $y_i$ together with an adjustment to compensate for transformation, and end up with the induced likelihood on the original data. This induced likelihood will be comparable to the likelihood induced by $\\mathcal M_x$, and in general other models fit to the original, untransformed data.\n\n## A simple example\n\nLet's consider the `mpg` variable of the `mtcars` dataset, which comes with every R installation. We'll consider two models:\n\n1. a normal model for the original data, and\n1. a normal model on log transformed data.\n\nThe data is boring, whatever, here's a histogram:\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\nFirst let's do some basic prep work and load our data, and define the transformation and the inverse transformation. We'll also create the transformed data set.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- mtcars$mpg\n\ntrans <- function(x) log(x)\ninv_trans <- function(y) exp(y)\n\ny <- trans(x)\n```\n:::\n\nIn our case, we're using a `log()` transformation, which is nice because we need both the derive and the inverse of this function, and both of these are easy to figure out. \n\nAside: for some traditional tranformations, such as Box-Cox transformations, or arcsine-square root transformation, finding the inverse by hand can be a pain. As a general rule, you can get the derivative either via automatic differentiation (not well supported in R) or numerical differentiation (moderately well supported in R). You can also use `uniroot()` to [find inverses](https://stackoverflow.com/questions/10081479/solving-for-the-inverse-of-a-function-in-r), but this approach is computationally expensive and I don't in general recommend it.\n\nI strongly encourage an enterprising R developer to create an R package that provides objects encoding one-to-one transformations and their inverses, thus enabling the rest of us to be lazy. At the moment, the best hack I've come across is to the leverage link functions and their inverses from `family` objects.\n    \nAnyway, at some point, you define the transformation, and the inverse transformation. It's a good idea to sanity check that the functions you write are actually inverses of each other:\n\n::: {.cell}\n\n```{.r .cell-code}\nx == inv_trans(trans(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE\n[13]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nx == trans(inv_trans(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE\n```\n:::\n:::\n\nIn my case, I'm working with `log()`s, and so there's some numerical error and my inverses are not quite exact. In practice, it turns out that I can ignore this for this post, but this may not always be case^[John Cook has a [blog post](https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/) that's a nice introduction if you haven't seen floating point arithmetic before. After that @goldberg_what_1991 is a classic reference worth at least skimming.].\n\nOkay, now let's define a function that computes the induced log-likelihood of $\\mathcal M_y$ on the original, untransformated data. For convenience, I'm going to assume that our model is represented as a `distribution` object from my [`distributions3`](https://alexpghayes.github.io/distributions3/) package.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(distributions3)\nlibrary(numDeriv)\n\nset.seed(27)\n\n#' @param dist The model fit to the transformed data `y`, as\n#'   a `distributions3::distribution` object.\n#' @param y The tranformed data.\n#' @param inv_trans The inverse transformation function.\ninduced_log_likelihood <- function(dist, y, inv_trans) {\n  \n  # note that grad() is a function from the numDeriv package\n  # for numerical differentiation. automatic differentiation\n  # would be slightly more computationally efficient but is\n  # not as supported in R\n  \n  log_likelihood(dist, y) - sum(log(abs(grad(inv_trans, y))))\n}\n```\n:::\n\nNow we fit normal models to the original and the transformed data using MLE estimators.\n\n::: {.cell}\n\n```{.r .cell-code}\nx_fit <- fit_mle(Normal(), x)\ny_fit <- fit_mle(Normal(), y)\n```\n:::\n\nAt first glance, you might want to compare the likelihood of these models, but you should not, since `x_fit` and `y_fit` are not fit to the same data!\n\n::: {.cell}\n\n```{.r .cell-code}\n# misleading! don't do this when y = g(x)!\nlog_likelihood(x_fit, x)\nlog_likelihood(y_fit, y)\n```\n:::\n\nInstead we want to compare the likelihood from the model fit to `x` and the induced likelihood on the $x$ from the fit to `y`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_likelihood(x_fit, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -102.3857\n```\n:::\n\n```{.r .cell-code}\ninduced_log_likelihood(y_fit, y, inv_trans)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -100.781\n```\n:::\n:::\n\nIn our case, it looks like the transformed fit is slightly better (recall that more positive log-likelihoods are better). It's a bit hard to interpret log-likelihoods until you start playing with them more, but this is a relatively small practical difference.\n\n## A linear regression example\n\nNow we'll leave the pleasant world of `distributions3` and do a more practical linear regression example. Now we'll use `mpg` as an outcome of a simple linear regression, and use the `wt` variable from the `mtcars` dataset as a predictor. We start by fitting out models, again using the `log()` transformation we previously defined.\n\n::: {.cell}\n\n```{.r .cell-code}\noriginal_fit <- lm(mpg ~ wt, mtcars)\ntransformed_fit <- lm(trans(mpg) ~ wt, mtcars)\n```\n:::\n\nNow we need a way to compute the log-likelihood of these models. We leverage the existing `logLik()` function for this.\n\n::: {.cell}\n\n```{.r .cell-code}\n# only works for lm-like objects, but hopefully easy to generalize\n# returns a logLik object\ninduced_logLik <- function(fit, inv_trans) {\n  y <- model.response(model.frame(fit))\n  logLik(fit) - sum(log(abs(grad(inv_trans, y))))\n}\n```\n:::\n\nThis let's us compare the original model and the transformed model:\n\n::: {.cell}\n\n```{.r .cell-code}\nlogLik(original_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'log Lik.' -80.01471 (df=3)\n```\n:::\n\n```{.r .cell-code}\ninduced_logLik(transformed_fit, inv_trans)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'log Lik.' -75.21614 (df=3)\n```\n:::\n:::\n\nAgain, it looks like the transformed model is slightly better (recall that high bigger densities are more likely, so high log-likelihoods are more probable). However, these models are not nested, and so we cannot apply standard likelihood ratio tests (or Wald or Rao tests).\n\nYou may have been taught that this makes these models incomparable, but this is not the case. The log-likelihood is a proper scoring rule, and so all we really want is to minimize the log-likelihood, as measured on the original, untransformed data. The real issue is that there isn't a nice analytical form for a likelihood ratio test.\n\nHowever, we can use the bootstrap to estimate a sampling distribution for the log-likelihoods of these models, just like we might with another loss function like mean square error^[You could also do cross-validation, but it turns out that it's more difficult than I expected to calculate out-of-sample predictive likelihoods in R. The optimism bootstrap is a nice option here, since you get an approximately unbiased measure risk estimate without having to do out-of-sample calculations.].\n\nAnyway, here's some code for a simple bootstrap:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(rsample)\nlibrary(purrr)\n\nboots <- bootstraps(mtcars, times = 200)\n\nfit_on_original_data <- function(split)\n  lm(mpg ~ wt, analysis(split))\n\nfit_on_transformed_data <- function(split)\n  lm(trans(mpg) ~ wt, analysis(split))\n\nfits <- boots %>% \n  mutate(\n    original_fit = map(splits, fit_on_original_data),\n    transformed_fit = map(splits, fit_on_transformed_data),\n    original_llh = map_dbl(original_fit, logLik),\n    induced_llh = map_dbl(transformed_fit, induced_logLik, inv_trans),\n  ) %>% \n  mutate_if(~inherits(.x, \"logLik\"), as.numeric)\n```\n:::\n\nAt this point you could do a paired T-test on the differences, or you could just plot the paired differences in log-likelihoods between the models, resulting in the following:\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\nAgain, it seems like the transformed model is better, although only marginally so. You could also compare the AIC and BIC of the two models.\n\n::: {.cell}\n\n```{.r .cell-code}\ninduced_AIC <- function(fit, inv_trans) {\n  lls <- induced_logLik(fit, inv_trans)\n  -2 * as.numeric(lls) + 2 * attr(lls, \"df\")\n}\n\ninduced_BIC <- function(fit, inv_trans) {\n  lls <- induced_logLik(fit, inv_trans)\n  nos <- attr(lls, \"nobs\")\n  -2 * as.numeric(lls) + log(nos) * attr(lls, \"df\")\n}\n\nAIC(original_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 166.0294\n```\n:::\n\n```{.r .cell-code}\ninduced_AIC(transformed_fit, inv_trans)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 156.4323\n```\n:::\n:::\n\nSo tranformation is better in terms of AIC (smaller is better).\n\n::: {.cell}\n\n```{.r .cell-code}\nBIC(original_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 170.4266\n```\n:::\n\n```{.r .cell-code}\ninduced_BIC(transformed_fit, inv_trans)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 160.8295\n```\n:::\n:::\n\nIt is also better in terms of BIC (smaller is better)[^deviance].\n\n[^deviance]: It is also fairly natural to compare the deviance of the transformed and untransformed models, and in the process of playing with this, I can across the rather odd result that `deviance()` and `-2 * logLik()` don't return the same thing on `lm()` objects.\n    \n::: {.cell}\n\n```{.r .cell-code}\n# these should be equal, but are not\ndeviance(original_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 278.3219\n```\n:::\n\n```{.r .cell-code}\nas.numeric(-2 * logLik(original_fit))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 160.0294\n```\n:::\n:::\n    \nI'm guessing that these differ by a scaling factor only, since it's pretty common to omit constant terms from likelihood calculations for efficiency, but also it does result in mysteries like this. It looks like someone else [came across a similar thing for GLMs](https://stats.stackexchange.com/questions/237702/comparing-models-using-the-deviance-and-log-likelihood-ratio-tests), so heads up I guess.\n\n## For skeptical machine learners\n\nIf you come from a machine learning background, you may find this whole exercise pointless, for two reasons.\n\nThe first is that you're probably using an estimator that doesn't give you densities for your predictions, so comparing likelihoods of transformed and untransformed models isn't possible for you. It probably feels natural to get predictions using your model fit to the transformed data, and then backtransform to get predictions on the original scale. \n\nThis is what `sklearn` does with the [`TransformedTargetRegressor`](https://scikit-learn.org/stable/modules/generated/sklearn.compose.TransformedTargetRegressor.html), for example. You may be surprised to learn that this approach does not in general result in consistent predictions for conditional means! See @duan_smearing_1983 for a short, pleasant read on why this is not the case, as well as an introduction to Duan's smearing estimator, which is consistent for prediction under some relatively sane conditions on the transformation $g$. As a general rule, backtransformed predictions can be surprisingly nasty to reason about.\n\nYou might also have a second complaint, which is that the likelihood is dumb loss function, and that you should use mean squared error instead. If this is the case, invite your friendly neighborhood Bayesian to yell at you.\n\n### One final trick: Box-Cox transformations\n\nIt turns out that this likelihood adjustment trick is also how to people estimate the optimal $\\lambda$ for Box-Cox transformations. The Box-Cox transformation is a slight variation on a power tranformation such that $\\lambda = 0$ corresponds to taking a logarithm, and looks like:\n\n\\begin{align}\n  y &=\n  \\begin{cases}\n    \\displaystyle \\frac{x^\\lambda - 1}{\\lambda} & \\text{ if } \\lambda \\neq 0 \\\\\n    \\log x & \\text{ if } \\lambda = 0\n  \\end{cases}\n\\end{align}\n\nIf you want to do a quick transformation of $y$, you can fit a normal distribution to $y$. Using `distributions3`, we can compute the log-likelihood on the original data via the transformation adjustment.\n\n::: {.cell}\n\n```{.r .cell-code}\nboxcox <- function(x, lambda) {\n  if (lambda == 0) log(x) else (x^lambda - 1) / lambda\n}\n\n# i calculated this inverse by hand which was fine\n# but wow yeah it would be really nice to have a package\n# that automatically finds inverses for common bijections\ninv_boxcox <- function(y, lambda) {\n  if (lambda == 0) exp(y) else (lambda * y + 1)^(1 / lambda)\n}\n\n# not vectorized in lambda!\nsimple_boxcox_log_likelihood <- function(x, lambda) {\n  y <- boxcox(x, lambda)\n  y_fit <- fit_mle(Normal(), y)\n  log_likelihood(y_fit, y) - \n    sum(log(abs(grad(inv_boxcox, y, lambda = lambda))))\n}\n```\n:::\n\nIf we plot this log-likelihood as a function of $\\lambda$ we see that a `log` transformation is about optimal.\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\nWe could also fit more complicated models to $y$. For example, a simple linear regression.\n\n::: {.cell}\n\n```{.r .cell-code}\n# not vectorized in lambda!\nprofile_boxcox_log_likelihood <- function(x, z, lambda) {\n  \n  # x is the original data\n  # y the transformed data\n  # z is a predictor in a linear regression of z on y\n  y <- boxcox(x, lambda)\n  y_fit <- lm(y ~ z)\n  logLik(y_fit) - sum(log(abs(grad(inv_boxcox, y, lambda = lambda))))\n}\n```\n:::\n\nUsing the `wt` variable from the `mtcars` dataset as a predictor for `y` in a linear regression, we now find that something more like an inverse quartic root transformation is optimal.\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n## TL; DR\n\n1. Comparing models with transformed and non-transformed outcomes is hard. You should probably use held-out induced likelihoods for these comparisons, or maybe the [optimism bootstrap](https://www.alexpghayes.com/blog/predictive-performance-via-bootstrap-variants/).\n\n1. Prediction is hard with transformations. Use Duan's Smearing estimator. Also, please, please, please report error on the original scale. Nobody knows how to interpret the root mean square error of log home price.\n\n1. Transforming your outcome, with either a direct transformation or a link function, *dramatically* changes the interpretation of parameters in your model.\n\n1. There isn't much computational infrastructure to support inference after transformation, so be aware of how this can cause frustration down the line. \n\n1. Just use a GLM with a link function instead. You can thank me later.\n\nThanks to Aki Vehtari for writing an [FAQ on cross-validation][cv-faq] with some comments on transformed outcomes. I didn't understand some of his comments, and this post is largely a result of me sorting those comments out for myself. Also thanks to commenters who point out helped me when I got stuck in this [Stan discourse thread](https://discourse.mc-stan.org/t/jacobian-correction-to-likelihood-of-transformed-response/13780).\n\nIf you are interested in trying out many transformations all at once, with a Gaussian model on the transformed outcome, you may be interested in the [`trafo`](https://cran.r-project.org/web/packages/trafo/index.html) package (@medina_r_2019). The associated [paper in the R journal](https://journal.r-project.org/archive/2019/RJ-2019-054/index.html) derives likelihood adjustments for an enormous number of common transformations. Note that `trafo` takes a rather different approach to model selection that I do in this blog post -- i.e. it helps you find a transformation of your outcome that has normally distributed errors with constant variance, whereas I instead suggest choosing the model that minimizes out-of-sample log-likelihood.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}